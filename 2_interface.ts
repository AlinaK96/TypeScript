// тип для обьектов или классов, где мы указываем поля/функции для этих обьектов
//ни во что не будут компилироваться
//Возможности, которые есть у интерфейсов, но нет у типов:

// - Декларативное расширение (мерджинг)
// - Расширение интерфейсов

interface Rect {
    readonly id: string //readonly - только для чтения
    color?: string        //вопрос для добавления необязательности этому параметру
    size: {
        width: number
        height: number
    }
}

const rect1: Rect ={
    id: '15541',
    color:'red',
    size:{
        width:20,
        height:35
    }
}

const rect2: Rect = {
    id: '451',
    size:{
        width: 15,
        height: 95
    }
}

rect2.color = 'black' 

const rect3 = {} as Rect
const rect4 = <Rect>{}


// наследование интерфейсов
//Само расширение происходит следующим образом:

//interface название extends родитеский_интерфейс {
    // ключи и типы}

interface RectWithAread extends Rect{
    getArea: () => number
}

const rect5: RectWithAread = {
    id: '646513',
    size: {
        width: 15,
        height: 15
    },
    getArea(): number {
        return this.size.width *this.size.height
    }
    
}

// взаимодействие с классами

interface Iclock {
    time: Date
    setTime(date:Date): void
}

class Clock implements Iclock {
    time: Date = new Date()
    setTime(date: Date): void {
        this.time = date
    }
}

// интерфейс для обьекта с динамичискими ключами

interface Styles {
    [key : string]: any; // любой тип данных
}

const css: Styles = {
    border: '1px solid black',
    top: '2px',
    borderRadius: '3px'
}

// Как мы видим два интерфейса с одинаковым именем стали одним целым. 
// И теперь при использовании данного интерфейса TypeScript требует чтобы 
// у объекта были свойства и из первого интерфейса и из второго одноименного


// типы созданы для статического использования. их объявили и используете, особо не расширяя их, 
// когда интерфейсы созданы именно для того, чтобы расширять их
// Представьте, что у нас в двух комнатах есть собаки и кошки. Кошки мяукают, собаки гавкают. 
// Если мы объединим их, то будут кошки или собаки. Так как мы теперь не знаем кто мяукает, а кто гавкает, то мы можем использовать 
// только общие методы и свойства, например: ходить().

// А теперь давайте пересечем данные объекты. И кошки, и собаки являются животными, так что у нас по сути полное пересечение, 
// а значит финальный объект сможет и гавкать, и мяукать.


// Объединение - это всегда или
// Пересечение - это всегда и